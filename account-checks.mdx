# Account Checks

Account checks are one of the most important important things we must consider to secure our Solana programs. If you have a background in Anchor, you may be familiar with the similar concept of [account constraints](https://www.anchor-lang.com/docs/account-constraints). Here is a list of common account checks you should consider performing, along with _how_ and _why_.

#### Which checks should I perform?

- Program ID Checks
- Sysvar Checks
- Owner Checks
- Signer Checks
- Mint Checks
- PDA Checks

### 1. Program ID Checks

When invoking others programs in your program, such as the `TokenProgram`, you must ensure that the account passed in for each program has the desired address. Failing to do so enables attackers to inject a program of another address with a conforming API that could be used to steal your funds, or break other constraints that depend upon the correct address of this program such as the `AssociatedTokenProgram`.

#### Anchor Example

In anchor, we solve for these checks with [Program&lt;T&gt;](https://github.com/coral-xyz/anchor/blob/master/lang/src/accounts/program.rs#L30). Below is an example using it in conjunction with the `Token` program type:

```rs
#[derive(Accounts)]
struct Transfer<'info> {
    token_program: Program<'info, Token>
}
```

In this example:

- `Program<T>` ensures the account is executable, and
- `Token` its address is equal to `TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA`

#### Native Rust Example

In Native Rust, we would typically handle those checks in the body of our instruction like this:

```rs
assert!(&token_program.executable);
assert_eq!(&spl_token::ID, &token_program.key);
```

##### Optimizations

When the desired Program ID is known, it is generally possible to omit the executable check, as having the correct Program ID already enables us to know that it is executable. There are also runtime errors that will occur when attempting to execute instructions against a non-executable account.

#### 2. Sysvar Checks 

When using Sysvar accounts, we need to check that they:

a) Are owned by the Sysvar program, and/or

b) Have the correct address

Failing to perform these checks enables an attacker to inject fake Sysvar accounts and potentially exploit your program. 

In anchor, we solve for these checks with `Sysvar<T>`. Below is an example using it in conjunction with the `Rent` sysvar account type:

```rs
#[derive(Accounts)]
struct Initialize<'info> {
    pub rent: Sysvar<'info, Rent>,
}
```

In this example:

- `Sysvar<T>` ensures the account is owned by `Sysvar1111111111111111111111111111111111111`
- `Rent` ensures its address is equal to `SysvarRent111111111111111111111111111111111 `

In Native Rust, we would handle this like so:

```rs
assert_eq!(&sysvar::ID, &rent.owner);
assert_eq!(&sysvar::rent::ID, &rent.key);
```

#### Optimizations

In practice, the Sysvar program owned check can be omitted, as knowing the account has the correct address already enables us to infer that it belongs to the Sysvar program.

If security is your main concern, it is often best to access Sysvar data directly from the sysvar syscalls instead of passing in an account, like so:

```rs
let clock = Clock::get()?;
```

Relying upon the s this closes off all possible account-based attack vectors. To get the sysvar from the syscall directly:

**Advanced Optimizations**

When prioritizing for peak performance, if you are not constrained by the number of accounts, it will typically be preferable to pass in Sysvar accounts instead of invoking the Sysvar syscalls. This is because the base cost of invoking Sysvar syscalls is `100 CUs`, however when paired with an efficient entrypoint, passing in the account can actually achieve the same result for `~10CUs`.

#### 3. Owner Checks

When reading from/writing to accounts, it is important to check that the account 

a) `owner` matches the correct Program ID, and

b) is of the correct type, typically handled by checking `data` length, or using an account discriminator

By knowing that the account is created by the correct program, and that the data length or content is

It is possible to skip owner checks for accounts owned by your own program when we are mutating their data or lamports, as if they do not belong to your program, the runtime will throw a privelege escalation error, causing your transaction to fail.

4. Signer Checks

```rs
assert!(maker.is_signer);
```