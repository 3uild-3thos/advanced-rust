# Account Checks

Account checks are one of the most important important things we must consider to secure our Solana programs. If you have a background in Anchor, you may be familiar with the similar concept of [account constraints](https://www.anchor-lang.com/docs/account-constraints). Here is a list of common account checks you should consider performing, along with _how_ and _why_.

#### Which checks should I perform?

Here is a brief checklist you run through every time you write a Native Rust program:

- [ ] Program ID Checks
- [ ] Sysvar Checks
- [ ] Owner Checks
- [ ] Signer Checks
- [ ] Mint Checks
- [ ] PDA Checks
- [ ] Close Account Checks

There are many other things you will likely need to consider to fully secure your program, but these are the most common footguns you will come up against. Having a checklist is a great way to make sure you have taken all of these things into account. Upon completing this checkilst, we can then look to optimize for CUs by omitting some of the more superfluous checks.

### 1. Program ID Checks

When invoking others programs in your program, such as the `TokenProgram`, you must ensure that the account passed in for each program has the desired address. Failing to do so enables attackers to inject a program of another address with a conforming API that could be used to steal your funds, or break other constraints that depend upon the correct address of this program such as the `AssociatedTokenProgram`.

#### Anchor Example

In anchor, we solve for these checks with [Program&lt;T&gt;](https://github.com/coral-xyz/anchor/blob/master/lang/src/accounts/program.rs#L30). Below is an example using it in conjunction with the `Token` program type:

```rs
#[derive(Accounts)]
struct Transfer<'info> {
    token_program: Program<'info, Token>
}
```

In this example:

- `Program<T>` ensures the account is executable, and
- `Token` its address is equal to `TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA`

#### Native Rust Example

In Native Rust, we would typically handle those checks in the body of our instruction like this:

```rs
assert!(&token_program.executable);
assert_eq!(&spl_token::ID, &token_program.key);
```

#### Optimizations

When the desired Program ID is known, it is generally possible to omit the executable check, as having the correct Program ID already enables us to know that it is executable. There are also runtime errors that will occur when attempting to execute instructions against a non-executable account.

### 2. Sysvar Checks 

When using Sysvar accounts, we need to check that they:

1. Are owned by the Sysvar program, and/or
2. Have the correct address

Failing to perform these checks enables an attacker to inject fake Sysvar accounts and potentially exploit your program. 

In anchor, we solve for these checks with `Sysvar<T>`. Below is an example using it in conjunction with the `Rent` sysvar account type:

```rs
#[derive(Accounts)]
struct Initialize<'info> {
    pub rent: Sysvar<'info, Rent>,
}
```

In this example:

- `Sysvar<T>` ensures the account is owned by `Sysvar1111111111111111111111111111111111111`
- `Rent` ensures its address is equal to `SysvarRent111111111111111111111111111111111 `

In Native Rust, we would handle this like so:

```rs
assert_eq!(&sysvar::ID, &rent.owner);
assert_eq!(&sysvar::rent::ID, &rent.key);
```

#### Optimizations

In practice, the Sysvar program owner check can be omitted, as knowing the account has the correct address already enables us to infer that it belongs to the Sysvar program.

If security is your main concern, it is often best to access Sysvar data directly from the sysvar syscalls instead of passing in an account, like so:

```rs
let clock = Clock::get()?;
```

Relying upon the syscall enables us to be sure that we have closed off all possible account-based attack vectors for our sysvar variables.

**Extreme Optimizations**

Contrarily, when prioritizing for peak performance, if your instruction is not bound by instruction data size, it can actually be more efficient to pass in Sysvar accounts than to invoke the Sysvar syscalls. This is because the base cost of invoking Sysvar syscalls is `100 CUs`, however when paired with an efficient entrypoint like [nostd-entrypoint](https://github.com/cavemanloverboy/solana-nostd-entrypoint) or [pinocchio](https://github.com/febo/pinocchio), passing in the account can actually achieve the same result for roughly `10CUs`.

### 3. Owner Checks

When reading from/writing to accounts, it is important to check that the account 

1. `owner` matches the correct Program ID, and
2. is of the correct type - typically handled by checking `data` length, or using an account discriminator

By knowing that the account is created by the correct program, and that the data length or discriminator is as expected, we can know that the account is genuine. Failure to perform this check may enable an attacked to inject malicious accounts that

#### Anchor Example

In anchor, we solve for these checks with [Account&lt;T&gt;](https://github.com/coral-xyz/anchor/blob/master/lang/src/accounts/program.rs#L30). It takes in a generic type that implements the `Owner` trait which is typically automatically set to checked for `crate::ID` by the `#[account]` macro. This means Account will be automatically checking for the Program ID of your own program as declared in `lib.rs`, or alternatively the Program ID of any program you are importing via `Cargo.toml`.

```rs
#[derive(Accounts)]
struct Transfer<'info> {
    escrow: Account<'info, Escrow>
}
```

In this example:

- `Account<T>` ensures type `T` implements has the correct `owner` and `discriminator`, then deserializes the account data
- `Token` implements the `Owner` and `AccountDeserialize` traits, enabling the `Account<T>` checks to work

#### Native Rust Example

In Native Rust, we might handle these checks in the body of our instruction like so:

```rs
// Create an account discriminator for Escrow type
const ESCROW_DISCRIMINATOR: u8 = 1;

// Split the discriminator out from account data
let (discriminator, data) = escrow.data.borrow()
	.split_first()
	.ok_or(ProgramError::InvalidInstructionData)?;

// Check the discriminator
assert_eq!(&ESCROW_DISCRIMINATOR, discriminator);

// Ensure the Escrow account is owned by the current program
assert_eq!(&crate::ID, &escrow.owner);

// Deserialize data into Escrow struct
let escrow_data = Escrow::try_unpack(data)?;
```

#### Optimizations

It is possible to skip owner checks for accounts owned by your own program when you are either:

1. mutating the `lamports` balance of the account without CPI
2. mutating the `data` of the account in your program

This is because attempting to modify memory that your program doesn't own will case the Solana runtime will throw a `InstructionError::PrivilegeEscalation` error, causing your transaction to fail. By virtue of this, if we are careful with our assumptions, it is possible to skip these checks to save on compute units.

### 4. Signer Checks

When dealing with the concept of permissions in our programs, we typically rely upon cryptogrpahic proofs of identity. While Soalana supports several cryptographic signature schemes, such as Ecdsa, Schnorr or RSA, the most common way of handling this is to simply  

```rs
assert!(maker.is_signer);
```